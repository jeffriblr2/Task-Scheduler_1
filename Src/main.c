/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"
#include "led.h"



#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
    enable_processor_faults();

	init_Scheduler_Stack(sched_stack_start);

	taskAddress[0]=(uint32_t) task1_run;
	taskAddress[1]=(uint32_t) task2_run;
	taskAddress[2]=(uint32_t) task3_run;
	taskAddress[3]=(uint32_t) task4_run;

	init_Tasks_Stack();

	led_init_all();

	init_Systick(ticks);

	switch_sp_to_psp();

	task1_run();
	for(;;);
}

void task1_run()
{
	while(1)
	{
		led_on(LED_GREEN);
		delay(DELAY_COUNT_1S);
		led_off(LED_GREEN);
		delay(DELAY_COUNT_1S);
	}
}

void task2_run()
{
	while(1)
	{
		led_on(LED_ORANGE);
		delay(DELAY_COUNT_500MS);
		led_off(LED_ORANGE);
		delay(DELAY_COUNT_500MS);
	}
}

void task3_run()
{
	while(1)
	{
		led_on(LED_BLUE);
		delay(DELAY_COUNT_250MS);
		led_off(LED_BLUE);
		delay(DELAY_COUNT_250MS);
	}
}

void task4_run()
{
	while(1)
	{
		led_on(LED_RED);
		delay(DELAY_COUNT_125MS);
		led_off(LED_RED);
		delay(DELAY_COUNT_125MS);
	}
}

void init_Systick(uint32_t ticks_hz)
{
	uint32_t* SRVR = (uint32_t*)0xE000E014;
	   uint32_t* SCSR = (uint32_t*)0xE000E010;  // SYSTICK CONTROL REGISTER
	   uint32_t count = (systick_clk/ticks_hz)-1;

	   *SRVR &= ~(0x00FFFFFF); // CLEAR VALUE OF SVR
	   *SRVR |= count; // LOAD VALUE INTO SVR

	   *SCSR |= (1<<1); //ENABLE SYSTEM EXCEPTION REQUEST
	   *SCSR |= (1<<2); //INDICATES CLOCK SOURCE, PROCESSOR CLOCK SOURCE
	   *SCSR |= (1<<0); //ENABLE SYSTICK Handler/Counter
}

__attribute__((naked)) void init_Scheduler_Stack(uint32_t SHED_StackStart)
{
    __asm volatile("MSR MSP,R0": : "r" (SHED_StackStart):);
    __asm volatile("BX LR");  //Copies value of LR into PC
}

__attribute__((naked)) void SysTick_Handler(void)
{
 /*Save context of current task*/
 //Get psp value of the current task
	__asm volatile("MRS R0,PSP");
// Using the above PSP value store SF2(R4 TO R11)
	__asm volatile("STMDB R0!,{R4-R11}"); //R0! points to the address where the first register in the list gets stored
	//Stmdb-->decrement before storing multiple registers

	__asm volatile("PUSH {LR}");
//Save current value of PSP
	__asm volatile("BL save_psp");

	 /*Retrieve context of next task*/
	//Decide the next task to run
	__asm volatile("BL update_next_task");

	//get its past psp value
	__asm volatile("BL get_psp");
	// Using the above PSP value retrieve SF2(R4 TO R11)
	__asm volatile("LDMIA R0!,{R4-R11}"); //R0! points to the address where the first register in the list gets loaded
	//ldmia-->load multiple registers and increment after

	//update psp and exit
	__asm volatile("MSR PSP,R0");

	__asm volatile("POP {LR}");
	__asm volatile("BX LR");
}

void save_psp(uint32_t current_psp_value)
{
	psp_of_tasks[current_task]=current_psp_value;
}

void init_Tasks_Stack()
{  uint32_t *pPsp;
  for(int i=0;i<Max_tasks;i++)
  {
    pPsp=(uint32_t*)psp_of_tasks[i];
    pPsp--;
    *pPsp=Dummy_xpsr;

    pPsp--;//PC
    *pPsp=taskAddress[i];

    pPsp--;//LR
    *pPsp=0xFFFFFFFD;
    for(int i=0;i<13;i++) //initializing Registers R0 to R12 as 0
    { pPsp--;
    *pPsp=0;
    }
    psp_of_tasks[i]=(uint32_t)pPsp; //Preserving value of PSP
  }
}

void enable_processor_faults()
{
	*SHCSR |= (1 << 16); // MEM MANAGE
	*SHCSR |= (1 << 17); // BUS FAULT
	*SHCSR |= (1 << 18); // USAGE FAULT
}

void HardFault_Handler(void)
{
  printf("Exception: Hard Fault\n");
  while(1);
}

void MemManage_Handler(void)
{
	  printf("Exception: Memory management Fault\n");
	  while(1);
}

void BusFault_Handler(void)
{
	  printf("Exception: Bus Fault\n");
	  while(1);
}
/*
void UsageFault_Handler(void)
{
	  printf("Exception: Usage Fault\n");
	  //printf("UFSR = %lx\n",(*UFSR) & 0xFFFF);
	  while(1);
}
*/
uint32_t get_psp(void)
{
 return psp_of_tasks[current_task];
}
__attribute__((naked)) void switch_sp_to_psp(void)
{
  // Initialize PSP with task 1 stack start address
	__asm volatile("PUSH {LR}"); //preserve LR which connects back to main
	__asm volatile("BL get_psp");
	__asm volatile("MSR PSP,R0"); //initialize psp
	__asm volatile("POP {LR}"); // pop back LR

 // change SP to PSP using Control register
	__asm volatile("MOV R0,#0X02");
	__asm volatile("MSR CONTROL,R0");
	__asm volatile("BX LR");

}

void update_next_task(void)
{
	current_task++;
	current_task=current_task%Max_tasks;
}
